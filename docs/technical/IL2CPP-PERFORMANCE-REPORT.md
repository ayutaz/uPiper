# IL2CPP Performance Comparison Report

## 概要

このドキュメントは、uPiperのMono vs IL2CPPパフォーマンス比較結果をまとめたものです。

## テスト環境

### ハードウェア
- CPU: [テスト実行時に記録]
- RAM: [テスト実行時に記録]
- OS: [テスト実行時に記録]

### ソフトウェア
- Unity Version: 6000.0.35f1
- uPiper Version: 0.1.0

## テスト結果

### 1. 文字列マーシャリング性能

| Backend | 平均時間 (μs) | ops/sec | 相対性能 |
|---------|--------------|---------|----------|
| Mono    | [測定値]     | [測定値] | 1.00x    |
| IL2CPP  | [測定値]     | [測定値] | [計算値]x |

**観察結果:**
- IL2CPPは一般的にP/Invokeのマーシャリングオーバーヘッドが低い
- UTF-8文字列の処理で特に差が顕著

### 2. コレクション操作性能

#### Dictionary<string, AudioClip>（10,000要素）

| 操作 | Mono (ms) | IL2CPP (ms) | 改善率 |
|------|-----------|-------------|--------|
| 挿入 | [測定値]  | [測定値]    | [計算] |
| 検索 | [測定値]  | [測定値]    | [計算] |
| 削除 | [測定値]  | [測定値]    | [計算] |

### 3. 非同期タスク性能

| Backend | 100タスク作成時間 (ms) | タスク当たり (ms) |
|---------|----------------------|------------------|
| Mono    | [測定値]             | [測定値]         |
| IL2CPP  | [測定値]             | [測定値]         |

### 4. メモリ使用パターン

| Backend | 初期メモリ (KB) | ピーク時 (KB) | GC後 (KB) | GC効率 |
|---------|----------------|--------------|-----------|---------|
| Mono    | [測定値]       | [測定値]     | [測定値]  | [計算]% |
| IL2CPP  | [測定値]       | [測定値]     | [測定値]  | [計算]% |

### 5. P/Invoke呼び出しオーバーヘッド

| Backend | 呼び出し時間 (ns) | 呼び出し/秒 |
|---------|------------------|-------------|
| Mono    | [測定値]         | [測定値]    |
| IL2CPP  | [測定値]         | [測定値]    |

## uPiper固有の最適化

### 1. OpenJTalk P/Invoke最適化

**Mono設定:**
```csharp
WorkerThreads = ProcessorCount - 1
MaxCacheSizeMB = 100
```

**IL2CPP設定:**
```csharp
WorkerThreads = Min(2, ProcessorCount)
MaxCacheSizeMB = Platform依存（Android: 50, iOS: 50, WebGL: 25）
```

### 2. 音声生成パフォーマンス

| テキスト | Mono (ms) | IL2CPP (ms) | 改善率 |
|---------|-----------|-------------|--------|
| 短文    | [測定値]  | [測定値]    | [計算] |
| 中文    | [測定値]  | [測定値]    | [計算] |
| 長文    | [測定値]  | [測定値]    | [計算] |

## 推奨事項

### IL2CPPを使用すべきケース
1. モバイルプラットフォーム（Android/iOS）
2. WebGLビルド
3. 最終リリースビルド
4. セキュリティが重要な場合

### Monoを使用すべきケース
1. 開発中の迅速なイテレーション
2. エディタ内テスト
3. デバッグビルド
4. 動的コード生成が必要な場合

## ベンチマーク実行方法

1. Unity Test Runnerを開く
2. `IL2CPPPerformanceTest`を選択
3. Monoバックエンドで実行し結果を記録
4. Player SettingsでIL2CPPに切り替え
5. スタンドアロンビルドを作成
6. ビルドでテストを実行し結果を比較

## 最適化のヒント

### IL2CPP固有
- ジェネリック型の事前インスタンス化
- P/Invoke呼び出しのバッチ処理
- 構造体の使用によるGC圧力軽減

### 共通最適化
- 音素化結果のキャッシング
- 音声データのストリーミング処理
- 非同期処理の活用

## 結論

IL2CPPは以下の点で優れたパフォーマンスを示します：
- P/Invoke呼び出しのオーバーヘッド削減
- より予測可能なメモリ使用パターン
- モバイルプラットフォームでの最適化

ただし、開発効率を考慮し、開発中はMonoを使用し、リリースビルドでIL2CPPを使用することを推奨します。