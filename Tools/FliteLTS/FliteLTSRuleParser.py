#!/usr/bin/env python3
"""
Flite LTS Rule Parser
Parses Flite's cmu_lts_model.c and generates C# rule data
"""

import re
import sys
import os
from datetime import datetime

class FliteLTSRuleParser:
    def __init__(self):
        self.rules = []
        self.state_map = {}
        self.current_letter = None
        self.letter_offsets = {}
        
    def parse_state_defines(self, header_file):
        """Parse state definitions from cmu_lts_model.h"""
        with open(header_file, 'r') as f:
            content = f.read()
            
        # Parse state definitions like: #define LTS_STATE_a_0 0x00,0x00
        pattern = r'#define\s+LTS_STATE_(\w+)_(\d+)\s+0x([0-9a-f]+),0x([0-9a-f]+)'
        matches = re.findall(pattern, content)
        
        for match in matches:
            letter, state_num, high_byte, low_byte = match
            state_value = (int(high_byte, 16) << 8) | int(low_byte, 16)
            state_key = f"LTS_STATE_{letter}_{state_num}"
            self.state_map[state_key] = state_value
            
        print(f"Parsed {len(self.state_map)} state definitions")
        
    def parse_model_data(self, model_file):
        """Parse the actual rule data from cmu_lts_model.c"""
        with open(model_file, 'r') as f:
            content = f.read()
            
        # Find the model array
        model_match = re.search(r'const\s+cst_lts_model\s+cmu_lts_model\[\]\s*=\s*\{(.*?)\};', 
                               content, re.DOTALL)
        if not model_match:
            raise ValueError("Could not find cmu_lts_model array")
            
        model_content = model_match.group(1)
        
        # Parse each rule entry
        # Format: feature, value, state_true, state_false,
        rule_pattern = r'/\*\*\s*letter\s+(\w+)\s*\*\*/|(\d+)\s*,\s*\'([^\']+)\'\s*,\s*(\w+)\s*,\s*(\w+)\s*,|(\d+)\s*,\s*(\d+)\s*,\s*(\d+),(\d+)\s*,\s*(\d+),(\d+)\s*,'
        
        current_offset = 0
        
        for line in model_content.split('\n'):
            line = line.strip()
            
            # Check for letter marker
            letter_match = re.match(r'/\*\*\s*letter\s+(\w+)\s*\*\*/', line)
            if letter_match:
                self.current_letter = letter_match.group(1)
                self.letter_offsets[self.current_letter] = current_offset
                continue
                
            # Parse regular rule
            rule_match = re.match(r'(\d+)\s*,\s*\'(.)\'\s*,\s*(\w+)\s*,\s*(\w+)\s*,', line)
            if rule_match:
                feature = int(rule_match.group(1))
                value = ord(rule_match.group(2))
                state_true = self.state_map.get(rule_match.group(3), 0)
                state_false = self.state_map.get(rule_match.group(4), 0)
                
                self.rules.append({
                    'offset': current_offset,
                    'letter': self.current_letter,
                    'feature': feature,
                    'value': value,
                    'next_true': state_true,
                    'next_false': state_false
                })
                current_offset += 1
                continue
                
            # Parse terminal rule (255 marker)
            terminal_match = re.match(r'255\s*,\s*(\d+)\s*,\s*(\d+),(\d+)\s*,\s*(\d+),(\d+)\s*,', line)
            if terminal_match:
                phoneme_index = int(terminal_match.group(1))
                
                self.rules.append({
                    'offset': current_offset,
                    'letter': self.current_letter,
                    'feature': 255,
                    'value': phoneme_index,
                    'next_true': 255,  # CST_LTS_EOR
                    'next_false': 0
                })
                current_offset += 1
                
        print(f"Parsed {len(self.rules)} rules")
        
    def generate_csharp_code(self, output_file):
        """Generate C# code with the parsed rules"""
        with open(output_file, 'w') as f:
            f.write(f"""// Auto-generated from Flite LTS rule data
// Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
// DO NOT EDIT - This file is automatically generated

using System;
using System.Collections.Generic;

namespace uPiper.Core.Phonemizers.Backend.Flite
{{
    /// <summary>
    /// Complete Flite LTS rule data extracted from CMU Flite source
    /// Contains {len(self.rules)} rules for accurate English phonemization
    /// </summary>
    public static class FliteLTSCompleteRules
    {{
        /// <summary>
        /// Complete LTS rules from Flite
        /// </summary>
        public static readonly WFSTRule[] Rules = new WFSTRule[]
        {{
""")
            
            # Write rules
            for i, rule in enumerate(self.rules):
                f.write(f"            new WFSTRule({rule['feature']}, {rule['value']}, "
                       f"{rule['next_true']}, {rule['next_false']}),")
                
                # Add comment every 100 rules
                if i > 0 and i % 100 == 0:
                    f.write(f" // Rule {i}")
                f.write("\n")
                
            f.write("""        };
        
        /// <summary>
        /// Letter to rule offset mapping
        /// </summary>
        public static readonly Dictionary<char, int> LetterOffsets = new Dictionary<char, int>
        {
""")
            
            # Write letter offsets
            for letter, offset in sorted(self.letter_offsets.items()):
                f.write(f"            {{ '{letter}', {offset} }},\n")
                
            f.write("""        };
        
        /// <summary>
        /// Get rule offset for a letter
        /// </summary>
        public static int GetLetterRuleOffset(char letter)
        {
            letter = char.ToLower(letter);
            return LetterOffsets.TryGetValue(letter, out var offset) ? offset : -1;
        }
        
        /// <summary>
        /// Total number of rules
        /// </summary>
        public const int RuleCount = """ + str(len(self.rules)) + """;
    }
}
""")
        
        print(f"Generated C# code with {len(self.rules)} rules to {output_file}")

def main():
    if len(sys.argv) < 4:
        print("Usage: python FliteLTSRuleParser.py <cmu_lts_model.h> <cmu_lts_model.c> <output.cs>")
        sys.exit(1)
        
    header_file = sys.argv[1]
    model_file = sys.argv[2]
    output_file = sys.argv[3]
    
    parser = FliteLTSRuleParser()
    
    # Parse state definitions
    parser.parse_state_defines(header_file)
    
    # Parse model data
    parser.parse_model_data(model_file)
    
    # Generate C# code
    parser.generate_csharp_code(output_file)

if __name__ == "__main__":
    main()