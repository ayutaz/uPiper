<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unity WebGL ONNX Runtime Integration Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            border-bottom: 3px solid #4CAF50;
            padding-bottom: 10px;
        }
        
        .test-section {
            margin: 20px 0;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 5px;
        }
        
        .test-section h2 {
            margin-top: 0;
            color: #555;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .output {
            background: #2d3748;
            color: #68d391;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            min-height: 100px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .error {
            color: #fc8181;
        }
        
        .warning {
            color: #f6e05e;
        }
        
        .success {
            color: #48bb78;
        }
        
        .status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 3px;
            font-weight: bold;
            margin: 5px;
        }
        
        .status.ready {
            background: #48bb78;
            color: white;
        }
        
        .status.loading {
            background: #ed8936;
            color: white;
        }
        
        .status.error {
            background: #f56565;
            color: white;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin: 5px 0;
        }
        
        audio {
            width: 100%;
            margin: 10px 0;
        }
        
        .phoneme-display {
            background: #edf2f7;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤ Unity WebGL Ã— ONNX Runtime Web çµ±åˆãƒ†ã‚¹ãƒˆ</h1>
        <p>å®Œå…¨ãªè¾æ›¸ï¼ˆNAIST Japanese Dictionaryï¼‰ã‚’ä½¿ç”¨ã—ãŸé«˜ç²¾åº¦ãªæ—¥æœ¬èªéŸ³å£°åˆæˆ</p>
        
        <div class="test-section">
            <h2>ğŸ“Š ã‚·ã‚¹ãƒ†ãƒ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</h2>
            <div>
                <span id="openjtalk-status" class="status loading">OpenJTalk: Loading...</span>
                <span id="onnx-status" class="status loading">ONNX Runtime: Not Loaded</span>
                <span id="model-status" class="status loading">Model: Not Loaded</span>
            </div>
        </div>
        
        <div class="test-section">
            <h2>ğŸ”§ åˆæœŸåŒ–</h2>
            <button onclick="initializeSystem()">ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–</button>
            <button onclick="loadONNXModel()">ONNXãƒ¢ãƒ‡ãƒ«ãƒ­ãƒ¼ãƒ‰</button>
            <button onclick="testWarmUp()">ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—</button>
        </div>
        
        <div class="test-section">
            <h2>ğŸ“ éŸ³ç´ å¤‰æ›ãƒ†ã‚¹ãƒˆ</h2>
            <input type="text" id="phoneme-test-input" value="ã“ã‚“ã«ã¡ã¯" placeholder="ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›">
            <button onclick="testPhonemize()">éŸ³ç´ å¤‰æ›</button>
            <div id="phoneme-output" class="phoneme-display">éŸ³ç´ çµæœãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™</div>
        </div>
        
        <div class="test-section">
            <h2>ğŸµ éŸ³å£°åˆæˆãƒ†ã‚¹ãƒˆ</h2>
            <input type="text" id="tts-input" value="ã“ã‚“ã«ã¡ã¯ã€ä»Šæ—¥ã¯ã„ã„å¤©æ°—ã§ã™ã­" placeholder="åˆæˆã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆ">
            <button onclick="testTTS()">éŸ³å£°åˆæˆ</button>
            <button onclick="testProblematicPhrases()">å•é¡Œãƒ•ãƒ¬ãƒ¼ã‚ºãƒ†ã‚¹ãƒˆ</button>
            <audio id="audio-player" controls style="display:none;"></audio>
        </div>
        
        <div class="test-section">
            <h2>ğŸ§ª è©³ç´°ãƒ†ã‚¹ãƒˆ</h2>
            <button onclick="testPhonemMapping()">éŸ³ç´ ãƒãƒƒãƒ”ãƒ³ã‚°æ¤œè¨¼</button>
            <button onclick="testONNXInference()">ONNXæ¨è«–ãƒ†ã‚¹ãƒˆ</button>
            <button onclick="compareWithWindows()">Windowsäº’æ›æ€§ãƒã‚§ãƒƒã‚¯</button>
            <button onclick="runFullTest()">å®Œå…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ</button>
        </div>
        
        <div class="test-section">
            <h2>ğŸ“‹ å‡ºåŠ›ãƒ­ã‚°</h2>
            <div id="output" class="output"></div>
        </div>
    </div>
    
    <!-- OpenJTalk Unity ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« -->
    <script src="StreamingAssets/openjtalk-unity.js"></script>
    <script src="StreamingAssets/openjtalk-unity-wrapper.js"></script>
    
    <!-- ONNX Runtime Web ãƒ©ãƒƒãƒ‘ãƒ¼ -->
    <script src="StreamingAssets/onnx-runtime-wrapper.js"></script>
    
    <script>
        const output = document.getElementById('output');
        let openjtalkReady = false;
        let onnxReady = false;
        
        function log(message, type = 'log') {
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'warning' ? 'warning' : type === 'success' ? 'success' : '';
            output.innerHTML += `<span class="${className}">[${timestamp}] ${message}</span>\n`;
            output.scrollTop = output.scrollHeight;
            console[type === 'error' ? 'error' : type === 'warning' ? 'warn' : 'log'](message);
        }
        
        async function initializeSystem() {
            log('ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ã‚’é–‹å§‹...');
            
            try {
                // OpenJTalkåˆæœŸåŒ–
                log('OpenJTalk ã‚’åˆæœŸåŒ–ä¸­...');
                await window.OpenJTalkUnityAPI.initialize();
                openjtalkReady = true;
                document.getElementById('openjtalk-status').className = 'status ready';
                document.getElementById('openjtalk-status').textContent = 'OpenJTalk: Ready';
                log('OpenJTalk åˆæœŸåŒ–å®Œäº†', 'success');
                
                // è¾æ›¸æƒ…å ±ã‚’ç¢ºèª
                const testText = 'ãƒ†ã‚¹ãƒˆ';
                const phonemes = await window.OpenJTalkUnityAPI.phonemize(testText);
                log(`è¾æ›¸å‹•ä½œç¢ºèª: "${testText}" â†’ ${phonemes}`);
                
            } catch (error) {
                log(`åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                document.getElementById('openjtalk-status').className = 'status error';
                document.getElementById('openjtalk-status').textContent = 'OpenJTalk: Error';
            }
        }
        
        async function loadONNXModel() {
            log('ONNX ãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ä¸­...');
            document.getElementById('onnx-status').className = 'status loading';
            document.getElementById('onnx-status').textContent = 'ONNX Runtime: Loading...';
            
            try {
                // ONNX Runtime Web åˆæœŸåŒ–
                const modelPath = 'StreamingAssets/ja_JP-test-medium.onnx';
                const configPath = 'StreamingAssets/ja_JP-test-medium.onnx.json';
                
                await window.UnityONNX.initialize(modelPath, configPath);
                
                onnxReady = true;
                document.getElementById('onnx-status').className = 'status ready';
                document.getElementById('onnx-status').textContent = 'ONNX Runtime: Ready';
                document.getElementById('model-status').className = 'status ready';
                document.getElementById('model-status').textContent = 'Model: Loaded';
                
                log('ONNX Runtime Web åˆæœŸåŒ–å®Œäº†', 'success');
                log('æ—¥æœ¬èªãƒ¢ãƒ‡ãƒ« (ja_JP-test-medium) ãƒ­ãƒ¼ãƒ‰å®Œäº†', 'success');
                
            } catch (error) {
                log(`ONNX ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                document.getElementById('onnx-status').className = 'status error';
                document.getElementById('onnx-status').textContent = 'ONNX Runtime: Error';
            }
        }
        
        async function testWarmUp() {
            if (!onnxReady) {
                log('å…ˆã«ONNXãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„', 'warning');
                return;
            }
            
            log('ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—ä¸­...');
            const dummyIds = [1, 7, 2]; // "^a$"
            
            try {
                const result = await window.UnityONNX.synthesize(dummyIds);
                if (result.success) {
                    log('ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—å®Œäº†', 'success');
                } else {
                    log('ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—å¤±æ•—', 'error');
                }
            } catch (error) {
                log(`ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }
        
        async function testPhonemize() {
            if (!openjtalkReady) {
                log('å…ˆã«ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–ã—ã¦ãã ã•ã„', 'warning');
                return;
            }
            
            const text = document.getElementById('phoneme-test-input').value;
            log(`éŸ³ç´ å¤‰æ›ãƒ†ã‚¹ãƒˆ: "${text}"`);
            
            try {
                const phonemes = await window.OpenJTalkUnityAPI.phonemize(text);
                const phonemeIds = await window.OpenJTalkUnityAPI.phonemesToIds(phonemes);
                
                const output = document.getElementById('phoneme-output');
                output.innerHTML = `ãƒ†ã‚­ã‚¹ãƒˆ: ${text}\n`;
                output.innerHTML += `éŸ³ç´ : ${phonemes}\n`;
                output.innerHTML += `éŸ³ç´ ID: [${phonemeIds.join(', ')}]\n`;
                output.innerHTML += `éŸ³ç´ æ•°: ${phonemeIds.length}`;
                
                log(`éŸ³ç´ å¤‰æ›æˆåŠŸ: ${phonemes}`, 'success');
                log(`éŸ³ç´ ID: [${phonemeIds.join(', ')}]`);
                
            } catch (error) {
                log(`éŸ³ç´ å¤‰æ›ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }
        
        async function testTTS() {
            if (!openjtalkReady || !onnxReady) {
                log('ã‚·ã‚¹ãƒ†ãƒ ã¨ONNXãƒ¢ãƒ‡ãƒ«ã‚’å…ˆã«åˆæœŸåŒ–ã—ã¦ãã ã•ã„', 'warning');
                return;
            }
            
            const text = document.getElementById('tts-input').value;
            log(`éŸ³å£°åˆæˆé–‹å§‹: "${text}"`);
            
            try {
                // éŸ³ç´ å¤‰æ›
                const phonemes = await window.OpenJTalkUnityAPI.phonemize(text);
                log(`éŸ³ç´ : ${phonemes}`);
                
                // éŸ³ç´ IDã«å¤‰æ›
                const phonemeIds = await window.OpenJTalkUnityAPI.phonemesToIds(phonemes);
                log(`éŸ³ç´ ID (${phonemeIds.length}å€‹): [${phonemeIds.join(', ')}]`);
                
                // ONNXæ¨è«–
                const startTime = performance.now();
                const result = await window.UnityONNX.synthesize(phonemeIds);
                const inferenceTime = performance.now() - startTime;
                
                if (result.success) {
                    log(`æ¨è«–å®Œäº† (${inferenceTime.toFixed(2)}ms)`, 'success');
                    
                    // éŸ³å£°å†ç”Ÿ
                    const audioData = result.data;
                    log(`éŸ³å£°ãƒ‡ãƒ¼ã‚¿: ${audioData.length} ã‚µãƒ³ãƒ—ãƒ« (${(audioData.length/22050).toFixed(2)}ç§’)`);
                    
                    // WAVãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
                    const wav = createWAV(audioData, 22050);
                    const url = URL.createObjectURL(wav);
                    
                    const player = document.getElementById('audio-player');
                    player.src = url;
                    player.style.display = 'block';
                    player.play();
                    
                    log('éŸ³å£°å†ç”Ÿé–‹å§‹', 'success');
                } else {
                    log(`æ¨è«–å¤±æ•—: ${result.error}`, 'error');
                }
                
            } catch (error) {
                log(`éŸ³å£°åˆæˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }
        
        async function testProblematicPhrases() {
            const phrases = [
                'ã“ã‚“ã«ã¡ã¯',
                'ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™',
                'ãŠç–²ã‚Œæ§˜ã§ã—ãŸ',
                'ä»Šæ—¥ã¯ã„ã„å¤©æ°—ã§ã™ã­',
                'ç§ã¯æ±äº¬ã«ä½ã‚“ã§ã„ã¾ã™'
            ];
            
            log('å•é¡Œã®ã‚ã‚‹ãƒ•ãƒ¬ãƒ¼ã‚ºã‚’ãƒ†ã‚¹ãƒˆä¸­...');
            
            for (const phrase of phrases) {
                log(`ãƒ†ã‚¹ãƒˆ: "${phrase}"`);
                document.getElementById('tts-input').value = phrase;
                await testTTS();
                await new Promise(resolve => setTimeout(resolve, 2000)); // 2ç§’å¾…æ©Ÿ
            }
        }
        
        async function testPhonemMapping() {
            log('éŸ³ç´ ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’æ¤œè¨¼ä¸­...');
            
            const testCases = [
                { text: 'ã¡', expected: 'ch i' },
                { text: 'ã¤', expected: 'ts u' },
                { text: 'ãã‚ƒ', expected: 'ky a' },
                { text: 'ã—ã‚ƒ', expected: 'sy a' },
                { text: 'ã«ã‚ƒ', expected: 'ny a' }
            ];
            
            for (const test of testCases) {
                try {
                    const phonemes = await window.OpenJTalkUnityAPI.phonemize(test.text);
                    const match = phonemes.includes(test.expected.replace(' ', ''));
                    
                    if (match) {
                        log(`âœ“ "${test.text}" â†’ ${phonemes}`, 'success');
                    } else {
                        log(`âœ— "${test.text}" â†’ ${phonemes} (æœŸå¾…: ${test.expected})`, 'error');
                    }
                } catch (error) {
                    log(`ã‚¨ãƒ©ãƒ¼: ${test.text}: ${error.message}`, 'error');
                }
            }
        }
        
        async function testONNXInference() {
            if (!onnxReady) {
                log('å…ˆã«ONNXãƒ¢ãƒ‡ãƒ«ã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„', 'warning');
                return;
            }
            
            log('ONNXæ¨è«–ã‚’ãƒ†ã‚¹ãƒˆä¸­...');
            
            // Windows ã¨åŒã˜éŸ³ç´ IDã§ãƒ†ã‚¹ãƒˆ
            const testIds = [0, 23, 30, 8, 4, 28, 9, 4, 32, 9, 4, 18, 1, 0];
            log(`ãƒ†ã‚¹ãƒˆID: [${testIds.join(', ')}]`);
            
            try {
                const result = await window.UnityONNX.synthesize(testIds);
                if (result.success) {
                    log(`æ¨è«–æˆåŠŸ: ${result.data.length} ã‚µãƒ³ãƒ—ãƒ«ç”Ÿæˆ`, 'success');
                    
                    // çµ±è¨ˆæƒ…å ±
                    const min = Math.min(...result.data);
                    const max = Math.max(...result.data);
                    const avg = result.data.reduce((a, b) => a + b, 0) / result.data.length;
                    
                    log(`çµ±è¨ˆ: Min=${min.toFixed(4)}, Max=${max.toFixed(4)}, Avg=${avg.toFixed(4)}`);
                } else {
                    log(`æ¨è«–å¤±æ•—: ${result.error}`, 'error');
                }
            } catch (error) {
                log(`æ¨è«–ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }
        
        async function compareWithWindows() {
            log('Windowsäº’æ›æ€§ã‚’ãƒã‚§ãƒƒã‚¯ä¸­...');
            
            const testText = 'ã“ã‚“ã«ã¡ã¯';
            const expectedIds = [0, 23, 30, 8, 4, 28, 9, 4, 32, 9, 4, 18, 1, 0];
            
            try {
                const phonemes = await window.OpenJTalkUnityAPI.phonemize(testText);
                const actualIds = await window.OpenJTalkUnityAPI.phonemesToIds(phonemes);
                
                log(`æœŸå¾…ID: [${expectedIds.join(', ')}]`);
                log(`å®Ÿéš›ID: [${actualIds.join(', ')}]`);
                
                const match = JSON.stringify(expectedIds) === JSON.stringify(actualIds);
                
                if (match) {
                    log('âœ“ Windows ã¨å®Œå…¨ä¸€è‡´ï¼', 'success');
                } else {
                    log('âœ— Windows ã¨ä¸ä¸€è‡´', 'error');
                }
                
            } catch (error) {
                log(`æ¯”è¼ƒã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }
        
        async function runFullTest() {
            log('===== å®Œå…¨ãƒ†ã‚¹ãƒˆé–‹å§‹ =====');
            
            await initializeSystem();
            await new Promise(r => setTimeout(r, 1000));
            
            await loadONNXModel();
            await new Promise(r => setTimeout(r, 1000));
            
            await testWarmUp();
            await new Promise(r => setTimeout(r, 1000));
            
            await testPhonemMapping();
            await new Promise(r => setTimeout(r, 1000));
            
            await compareWithWindows();
            await new Promise(r => setTimeout(r, 1000));
            
            await testProblematicPhrases();
            
            log('===== å®Œå…¨ãƒ†ã‚¹ãƒˆçµ‚äº† =====', 'success');
        }
        
        // WAVãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆãƒ˜ãƒ«ãƒ‘ãƒ¼
        function createWAV(audioData, sampleRate) {
            const length = audioData.length;
            const arrayBuffer = new ArrayBuffer(44 + length * 2);
            const view = new DataView(arrayBuffer);
            
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + length * 2, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(36, 'data');
            view.setUint32(40, length * 2, true);
            
            const pcmData = floatTo16BitPCM(audioData);
            const offset = 44;
            for (let i = 0; i < length; i++) {
                view.setInt16(offset + i * 2, pcmData[i], true);
            }
            
            return new Blob([arrayBuffer], { type: 'audio/wav' });
        }
        
        function floatTo16BitPCM(float32Array) {
            const int16Array = new Int16Array(float32Array.length);
            for (let i = 0; i < float32Array.length; i++) {
                const val = Math.max(-1, Math.min(1, float32Array[i]));
                int16Array[i] = val < 0 ? val * 0x8000 : val * 0x7FFF;
            }
            return int16Array;
        }
        
        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã«è‡ªå‹•åˆæœŸåŒ–
        window.addEventListener('load', () => {
            log('ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰å®Œäº†');
            log('ã€Œã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦é–‹å§‹ã—ã¦ãã ã•ã„');
        });
    </script>
</body>
</html>