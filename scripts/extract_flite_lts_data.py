#!/usr/bin/env python3
"""Extract Flite LTS data from C source files and generate C# code"""

import os
import re
import json
from datetime import datetime

class FliteLTSExtractor:
    def __init__(self, flite_path):
        self.flite_path = flite_path
        self.phone_table = []
        self.letter_table = []
        self.letter_index = []
        self.rule_data = []
        
    def extract_phone_table(self):
        """Extract phone table from cmu_lts_rules.c"""
        rules_path = os.path.join(self.flite_path, "lang", "cmulex", "cmu_lts_rules.c")
        
        with open(rules_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Find phone table
        phone_match = re.search(
            r'const char \* const cmu_lts_phone_table\[\d+\] = \s*\{([^}]+)\}',
            content, re.DOTALL
        )
        
        if phone_match:
            phone_data = phone_match.group(1)
            # Extract phone strings
            phones = re.findall(r'"([^"]+)"', phone_data)
            self.phone_table = [p for p in phones if p != "NULL"]
            print(f"Extracted {len(self.phone_table)} phones")
        
    def extract_letter_table(self):
        """Extract letter table from cmu_lts_rules.c"""
        rules_path = os.path.join(self.flite_path, "lang", "cmulex", "cmu_lts_rules.c")
        
        with open(rules_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Find letter table
        letter_match = re.search(
            r'const char \* const cmu_lts_letter_table\[\d+\] = \s*\{([^}]+)\}',
            content, re.DOTALL
        )
        
        if letter_match:
            letter_data = letter_match.group(1)
            # Extract letter strings
            letters = re.findall(r'"([^"]+)"', letter_data)
            self.letter_table = [l for l in letters if l != "NULL"]
            print(f"Extracted {len(self.letter_table)} letters")
    
    def extract_letter_index(self):
        """Extract letter index from cmu_lts_rules.c"""
        rules_path = os.path.join(self.flite_path, "lang", "cmulex", "cmu_lts_rules.c")
        
        with open(rules_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Find letter index
        index_match = re.search(
            r'const cst_lts_addr cmu_lts_letter_index\[\d+\] = \s*\{([^}]+)\}',
            content, re.DOTALL
        )
        
        if index_match:
            index_data = index_match.group(1)
            # Extract numbers
            indices = re.findall(r'(\d+)', index_data)
            self.letter_index = [int(i) for i in indices if i != '0' or len(self.letter_index) == 0]
            print(f"Extracted {len(self.letter_index)} letter indices")
    
    def extract_lts_model(self):
        """Extract LTS model data from cmu_lts_model.c"""
        model_path = os.path.join(self.flite_path, "lang", "cmulex", "cmu_lts_model.c")
        
        if not os.path.exists(model_path):
            print(f"Warning: {model_path} not found")
            return
            
        with open(model_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Find model data arrays
        # This is where the actual WFST rules are stored
        # We'll need to analyze the structure more carefully
        
        # For now, let's extract what we can find
        model_matches = re.findall(
            r'static const (unsigned char|cst_lts_rule) (\w+)\[\] = \{([^}]+)\}',
            content, re.DOTALL
        )
        
        for data_type, name, data in model_matches:
            print(f"Found {name} of type {data_type}")
            # Store for later processing
            
    def generate_csharp_code(self, output_path):
        """Generate C# code with extracted data"""
        
        cs_content = f"""// Auto-generated from Flite LTS data
// Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
// DO NOT EDIT - This file is automatically generated

using System;

namespace uPiper.Core.Phonemizers.Backend.Flite
{{
    /// <summary>
    /// Flite LTS data extracted from CMU Flite source
    /// </summary>
    public static class FliteLTSData
    {{
        /// <summary>
        /// Phone table containing all possible phones
        /// </summary>
        public static readonly string[] PhoneTable = new[]
        {{
{self._format_string_array(self.phone_table, indent=12)}
        }};

        /// <summary>
        /// Letter table for LTS rules
        /// </summary>
        public static readonly string[] LetterTable = new[]
        {{
{self._format_string_array(self.letter_table, indent=12)}
        }};

        /// <summary>
        /// Letter index for quick lookups
        /// </summary>
        public static readonly int[] LetterIndex = new[]
        {{
{self._format_int_array(self.letter_index, indent=12)}
        }};

        /// <summary>
        /// Total number of phones
        /// </summary>
        public const int PhoneCount = {len(self.phone_table)};

        /// <summary>
        /// Total number of letters
        /// </summary>
        public const int LetterCount = {len(self.letter_table)};
    }}
}}
"""
        
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(cs_content)
        
        print(f"Generated C# code at: {output_path}")
    
    def _format_string_array(self, items, indent=12):
        """Format string array for C# code"""
        if not items:
            return " " * indent + "// Empty array"
        
        lines = []
        for i in range(0, len(items), 8):  # 8 items per line
            batch = items[i:i+8]
            formatted = ', '.join(f'"{item}"' for item in batch)
            lines.append(" " * indent + formatted + ("," if i + 8 < len(items) else ""))
        
        return '\n'.join(lines)
    
    def _format_int_array(self, items, indent=12):
        """Format int array for C# code"""
        if not items:
            return " " * indent + "// Empty array"
        
        lines = []
        for i in range(0, len(items), 10):  # 10 numbers per line
            batch = items[i:i+10]
            formatted = ', '.join(str(item) for item in batch)
            lines.append(" " * indent + formatted + ("," if i + 10 < len(items) else ""))
        
        return '\n'.join(lines)
    
    def validate_data(self):
        """Validate extracted data"""
        print("\n=== Data Validation ===")
        print(f"Phone table entries: {len(self.phone_table)}")
        print(f"Letter table entries: {len(self.letter_table)}")
        print(f"Letter index entries: {len(self.letter_index)}")
        
        # Check if we have the expected number of entries
        if len(self.phone_table) < 50:
            print("Warning: Phone table seems too small")
        
        if len(self.letter_table) < 26:
            print("Warning: Letter table seems incomplete")
        
        if len(self.letter_index) != 27:  # a-z + null terminator
            print(f"Warning: Expected 27 letter indices, got {len(self.letter_index)}")
        
        return True

def main():
    # Path to Flite source
    flite_path = r"C:\Users\yuta\Desktop\Private\uPiper\NativePlugins\Flite\external\flite"
    
    # Output path for generated C# code
    output_path = r"C:\Users\yuta\Desktop\Private\uPiper\Assets\uPiper\Runtime\Core\Phonemizers\Backend\Flite\FliteLTSData.Generated.cs"
    
    print("=== Flite LTS Data Extractor ===")
    print(f"Flite source path: {flite_path}")
    
    # Create extractor
    extractor = FliteLTSExtractor(flite_path)
    
    # Extract data
    print("\nExtracting phone table...")
    extractor.extract_phone_table()
    
    print("\nExtracting letter table...")
    extractor.extract_letter_table()
    
    print("\nExtracting letter index...")
    extractor.extract_letter_index()
    
    print("\nExtracting LTS model...")
    extractor.extract_lts_model()
    
    # Validate
    if extractor.validate_data():
        # Generate C# code
        print("\nGenerating C# code...")
        extractor.generate_csharp_code(output_path)
        print("\nDone!")
    else:
        print("\nValidation failed. Please check the extracted data.")

if __name__ == "__main__":
    main()